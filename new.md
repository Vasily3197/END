![Логотип Git](Git-Logo-1788C.png)

# **Работа с Git и GitHub**

## *1. Что такое Git и зачем он нужен?*
Git - это консольная утилита, для отслеживания, ведения и контроля изменения файлов в проекте. Чаще всего эту программу используют для кода, но можно и для других файлов. Например, для картинок, что полезно для дизайнеров.

С помощью Git можно откатить свой проект до более старой версии, сравнивать, анализировать или сливать свои изменения в репозиторий - хранилище кода и истории его изменений. Git работает локально и все репозитории хранятся в определенных папках на жестком диске.
```
Так же репозитории можно хранить и в интернете. Обычно для этого используют три сервиса:

GitHub
Bitbucket
GitLab
```
Каждая точка сохранения проекта носит название коммит (commit). У каждого commit-a есть hash (уникальный id) и комментарий. Из таких commit-ов собирается ветка. 

Ветка - это история изменений. У каждой ветки есть свое название. Репозиторий может содержать в себе несколько веток, которые создаются из других веток или вливаются в них.
## *2. Как работает Git*
Hа картинке каждый кружок - это commit. Стрелки показывают направление, из какого commit сделан следующий. Например C3 сделан из С2 и т. д. Все эти commit находятся в ветке под названием main. Это основная ветка, чаще всего ее называют master . Прямоугольник main* показывает в каком commit мы сейчас находимся, проще говоря указатель.

![Тут должно было быть изображение стрелочек](Image1.png)

В итоге получается очень простой граф, состоящий из одной ветки (main) и четырех commit. Все это может превратиться в более сложный граф, состоящий из нескольких веток, которые сливаются в одну.

![Тут должно было быть изображение стрелочек](image2.png)

## *3. Установка Git*

Основой интерфейс для работы с Git является консоль/терминал. Это не совсем удобно, тем более для новичков, поэтому лучше всего поставить дополнительную программу с графическим интерфейсом (кнопками, графиками и т.д.).

Для начала нужно установить Git.

Если ОС Windows, то проходим по ссылке https://git-scm.com/download/win , выбираем под вашу ОС (32 или 64 битную), скачиваем и устанавливаем.

Если же Mac OS, то нужно открыть терминал и написать:

При условии, что установлен Homebrew
```
brew install git
```
Если нет, то вводим эту команду:
``` 
git --version
```
После этого появится окно, где предложит установить Command Line Tools (CLT).
Соглашаемся и ждем установки. Вместе с CLT установиться и git.

Для ОС Linux. Открываем терминал и вводим следующую команду:

Debian или Ubuntu
```
sudo apt install git
```

CentOS
```
sudo yum install git
```
## *4. Настройка Git*

Git установлен и можно им пользоваться. Но сначала нужно его настроить, чтобы при создании commit, указывался его автор.

Открываем терминал (Linux и MacOS) или консоль (Windows) и вводим следующие команды:

Для установки имени пользователя
```
git config --global user.name "<ваше_имя>"
```
Для установки электронной почты
```
git config --global user.email "<адрес_почты@email.com>"
```

## *5. Создание репозитория*

Создадим наш первый репозиторий. Для этого нужно пройти в папку вашего проекта.

Для Linux и MacOS путь может выглядеть так /Users/UserName/Desktop/MyProject

Для Windows например С://MyProject

cd <путь_к_вашему_проекту>

**Инициализация/создание репозитория**
```
git init
```
Теперь Git отслеживает изменения файлов проекта. Но, так как вы только создали репозиторий в нем нет кода. Для этого нужно создать commit.

Добавим все файлы проекта в будующий commit
```
git add .
```
или 
```
git add --all
```
Если хотим добавить конкретный файл то можно так:
```
git add <имя_файла> 
```
Теперь создаем commit. Обязательно указываем комментарий
и  не забываем про кавычки
```
git commit -m "<комментарий>"
```
## *6. Процесс работы с Git*
Не стоит после каждого изменения файла делать commit. Чаще всего их создают, когда:

*Создан новый функционал*

*Добавлен новый блок на верстке*

*Исправлены ошибки по коду*

*Вы завершили рабочий день и хотите сохранить код*

Это поможет держать ветки в чистоте и порядке. Тем самым, вы будете видеть историю изменений по каждому нововведению в вашем проекте, а не по каждому файлу.

## *7. Визуальный интерфейс*
 Существуют дополнительные программы для облегчения использования Git. Некоторые текстовые редакторы или полноценные среды разработки уже включают в себя вспомогательный интерфейс для работы с ним.

Но существуют и отдельные программы по работе с Git. Можно использовать эти:

*GitHub Desktop*

*Sourcetree*

*GitKraken*

## *8. Создание веток*

Ветка - это набор commit (кружок), которые идут друг за другом. У ветки есть название, основную ветку чаще всего называют master (на картинках будет называться main) . Если говорить простыми словами, то ветка master - это наш проект.

Другие ветки - это отдельное место для реализации нового функционала или исправление багов (ошибок) нашего проекта. То есть, с отдельной веткой вы делаете что угодно, а затем сливаете эти изменения в основную ветку master.

Не рекомендуется создавать commit напрямую в master . Лучше для этого заводить новую ветку и все изменения писать там.

![Тут должно было быть изображение стрелочек](image3.png)

Для того, чтобы создать новую ветку вводим:
```
git branch <название_ветки>
```
или
```
git checkout -b <название_ветки>
```
![Тут должно было быть изображение стрелочек](image4.png)

Эти команды делают тоже самое, только во втором случае можно сразу переключиться в новую ветку и сразу вносить в ней изменения.

При создании новой ветки, старайтесь называть ее кратким и ёмким именем. Чтобы сразу было понятно, что именно изменялось по проекту. Если вы используете, какую-нибудь систему для ведения задач, то можете в начале названия ветки указывать ID задачи, чтобы можно было легко найти, на основе какой задачи была создана ветка. 

Например вот так:
```
3424_fix_catalog_ajax
```
В каждом новом commit следует оставлять коммент и в нем описывать суть изменений.

Переключаться между ветками можно такой командой:
```
git checkout <название_ветки>
```
После того, как вы завершили работу над своей задачей, ветку можно слить в master . Для этого нужно переключиться в ветку master 
```
git checkout master
```
и выполнить следующую команду ( в данном примере это master):
```
git merge <название_ветки>
```
![Тут должно было быть изображение стрелочек](image5.png)

Команда merge берет все изменения из ветки (например bugFix) и добавляет их в ветку master.

Для того чтобы посмотреть текущее состояние ветки, например, какие файлы добавлены или не добавлены для создания commit, можно выполнить команду:
```
git status
```
## *9. Проблемы при создании веток*

Git старается автоматически сливать изменения, но иногда возникают конфликты. Например, когда в двух ветках были изменения в одной и той же строчке кода. Если такое произошло, то необходимо разрешить конфликт вручную. Для этого открываем файл там, где этого произошло.

Вместо:
```
git checkout new_styles
git merge master
```
По итогу можно увидеть это:
```
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
<html>
  <head>
    <link type="text/css" rel="stylesheet" media="all" href="style.css" />
  </head>
  <body>
    <h1>Hello,World!</h1>
  </body>
</html>
```
Первый раздел (HEAD) - это то, что находиться в текущей ветке, куда вы пытались слить код. 

Второй раздел (между ==== и >>>>master) - версия кода в ветке, откуда вы пытались слить код (в данном случае master). Для того, чтобы разрешить конфликт, стоит оставить стили и привести файл в такой вид:
```
<html>
  <head>
    <link type="text/css" rel="stylesheet" media="all" href="style.css" />
  </head>
  <body>
    <h1>Hello,World!</h1>
  </body>
</html>
```
После внесения нужных изменений добавьте ваш файл через git add <имя_файла> как измененный и создайте новый commit:
```
git add index.html
git commit -m "Merged master fixed conflict."
```
## *10. Вспомогательные команды*

Просмотреть изменения относительно двух веток можно командой:
```
git diff <исходная_ветка> <целевая_ветка>
```
Удалить ненужную ветку:
```
git branch -d <название_ветки>
```
Просмотр истории ветки:
```
git log
```
Подсказки по популярным командам:

по популярным командам
```
git help
```
по конкретной команде
```
git help <название_команды>
```
## 12. *Настройка .gitignore*

В большинстве проектов есть файлы или целые директории, в которые мы не хотим (и, скорее всего, не захотим) коммитить. Мы можем удостовериться, что они случайно не попадут в git add -A при помощи файла .gitignore

Создайте вручную файл под названием .gitignore и сохраните его в директорию проекта.
Внутри файла перечислите названия файлов/папок, которые нужно игнорировать, каждый с новой строки.
Файл .gitignore должен быть добавлен, закоммичен и отправлен на сервер, как любой другой файл в проекте.

Хорошие примеры файлов, которые нужно игнорировать:
~~~
Логи
Артефакты систем сборки
Папки node_modules в проектах node.js
Папки, созданные IDE, например, Netbeans или IntelliJ
Разнообразные заметки разработчика.
~~~
Файл .gitignore, исключающий все перечисленное выше, будет выглядеть так:
~~~
*.log
build/
node_modules/
.idea/
my_notes.txt
~~~
Символ слэша в конце некоторых линий означает директорию (и тот факт, что мы рекурсивно игнорируем все ее содержимое). Звездочка, как обычно, означает шаблон.

## *13. Создаем свой первый проект и выкладываем на GitHub*

Сначала нужно зарегистрироваться на GitHub.

Создаём папку, где будет храниться проект. Если такая папка уже есть, то создавать новую не надо.

После открываем VS Code.

![Тут должен быть скриншот VS Code](image6.png)

Установите себе дополнительно анализаторы кода для JavaScript и PHP
Откройте вашу папку, которую создали ранее

После этого у вас появится вот такой интерфейс:

![Тут должен быть скриншот VS Code](image7.png)

Если ваш проект пустой то создайте новый файл и назовите его index.html. После этого откроется окно редактирование этого файла. Напишите в нем ! и нажмите кнопку Tab . Автоматически должен сгенерироваться скелет пустой HTML страницы. Не забудьте нажать ctrl+s чтобы файл сохранился.

![Тут должен быть скриншот VS Code](image8.png)


После нажатия на кнопку 1 , появится всплывающее окно. Нужно выбрать второй вариант или там где присутствует фраза ...public repository

Если вы хотите создать локальный репозиторий и опубликовать код в другой сервис, то необходимо нажать на кнопку Initialize Repository . После этого, вручную выбрать сервис куда публиковать.

После того, как выбрали "Опубликовать на GitHub публичный репозиторий" (пункт 2), программа предложит вам выбрать файлы, которые будут входить в первый commit. Проставляем галочки у всех файлов, если не проставлены и жмем ОК . Вас перекинет на сайт GitHub, где нужно будет подтвердить вход в аккаунт.

Вы создали и опубликовали репозиторий на GitHub.

Теперь сделаем изменения в коде и попробуем их снова опубликовать. Перейдите во вкладку с файлами, отредактируйте какой-нибудь файл, не забудьте нажать crtl+s (Windows) или cmd+s (MacOS), чтобы сохранить файл. Вернитесь обратно во вкладу управления Git.

![Тут должен быть скриншот VS Code](image9.png)

Если посмотреть на значок вкладки Git, то можно увидеть цифру 1 в синем кружке. Она означает, сколько файлов у нас изменено и незакоммичено. Теперь закоммитим его и опубликуем:

Кнопка для просмотра изменений в файле. (Необязательно нажимать)

Добавляем наш файл для будущего commit

Пишем комментарий

Создаем commit

Отправляем наш commit в GitHub

## *14. Работа с удалённым репозиторием*

Просмотр удалённых репозиториев
Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду git remote. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум origin — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование:
~~~
$ git clone https://github.com/schacon/ticgit
Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin
~~~
Вы можете также указать ключ -v, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию:
~~~
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
~~~
Если у вас больше одного удалённого репозитория, команда выведет их все. Например, для репозитория с несколькими настроенными удалёнными репозиториями в случае совместной работы нескольких пользователей, вывод команды может выглядеть примерно так:
~~~
$ cd grit
$ git remote -v
bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)
cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)
koke      git://github.com/koke/grit.git (fetch)
koke      git://github.com/koke/grit.git (push)
origin    git@github.com:mojombo/grit.git (fetch)
origin    git@github.com:mojombo/grit.git (push)
~~~
Это означает, что мы можем легко получить изменения от любого из этих пользователей. Возможно, что некоторые из репозиториев доступны для записи и в них можно отправлять свои изменения, хотя вывод команды не даёт никакой информации о правах доступа.

Обратите внимание на разнообразие протоколов, используемых при указании адреса удалённого репозитория; 

*Добавление удалённых репозиториев*

Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду git remote add <shortname> <url>:
~~~
$ git remote
origin
$ git remote add pb https://github.com/paulboone/ticgit
$ git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
pb	https://github.com/paulboone/ticgit (fetch)
pb	https://github.com/paulboone/ticgit (push)
~~~
Теперь вместо указания полного пути вы можете использовать pb. Например, если вы хотите получить изменения, которые есть у кого - то, но нет у вас, вы можете выполнить команду git fetch pb:
~~~
$ git fetch pb
remote: Counting objects: 43, done.
remote: Compressing objects: 100% (36/36), done.
remote: Total 43 (delta 10), reused 31 (delta 5)
Unpacking objects: 100% (43/43), done.
From https://github.com/paulboone/ticgit
 * [new branch]      master     -> pb/master
 * [new branch]      ticgit     -> pb/ticgit
 ~~~

Ветка master из репозитория другого сейчас доступна вам под именем pb/master. Вы можете слить её с одной из ваших веток или переключить на неё локальную ветку, чтобы просмотреть содержимое ветки.

Получение изменений из удалённого репозитория — Fetch и Pull
Как вы только что узнали, для получения данных из удалённых проектов, следует выполнить:
~~~
$ git fetch [remote-name]
~~~
Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем «origin». Таким образом, git fetch origin извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью fetch). Важно отметить, что команда git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

Если ветка настроена на отслеживание удалённой ветки, то вы можете использовать команду git pull чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым или более удобным. К тому же, по умолчанию команда git clone автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали репозиторий. Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение git pull, как правило, извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.
~~~
Начиная с версии 2.27, команда git pull выдаёт предупреждение, если настройка pull.rebase не установлена. Git будет выводить это предупреждение каждый раз пока настройка не будет установлена.

Если хотите использовать поведение Git по умолчанию (простое смещение вперёд если возможно — иначе создание коммита слияния): git config --global pull.rebase "false"

Если хотите использовать перебазирование при получении изменений: git config --global pull.rebase "true"
~~~
*Отправка изменений в удалённый репозиторий (Push)*

Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: git push <remote-name> <branch-name>. Чтобы отправить вашу ветку master на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:
~~~
$ git push origin master
~~~
Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а после него выполнить команду push попытаетесь вы, то ваш push точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить push.

*Просмотр удалённого репозитория*

Если хотите получить побольше информации об одном из удалённых репозиториев, вы можете использовать команду git remote show <remote>. Выполнив эту команду с некоторым именем, например, origin, вы получите следующий результат:
~~~
$ git remote show origin
* remote origin
  Fetch URL: https://github.com/schacon/ticgit
  Push  URL: https://github.com/schacon/ticgit
  HEAD branch: master
  Remote branches:
    master                               tracked
    dev-branch                           tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)
~~~    
Она выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках. Эта команда любезно сообщает вам, что если вы, находясь на ветке master, выполните git pull, ветка master с удалённого сервера будет автоматически влита в вашу сразу после получения всех необходимых данных. Она также выдаёт список всех полученных ею ссылок.

Это был пример для простой ситуации и вы наверняка встречались с чем-то подобным. Однако, если вы используете Git более интенсивно, вы можете увидеть гораздо большее количество информации от git remote show:
~~~
$ git remote show origin
* remote origin
  URL: https://github.com/my-org/complex-project
  Fetch URL: https://github.com/my-org/complex-project
  Push  URL: https://github.com/my-org/complex-project
  HEAD branch: master
  Remote branches:
    master                           tracked
    dev-branch                       tracked
    markdown-strip                   tracked
    issue-43                         new (next fetch will store in remotes/origin)
    issue-45                         new (next fetch will store in remotes/origin)
    refs/remotes/origin/issue-11     stale (use 'git remote prune' to remove)
  Local branches configured for 'git pull':
    dev-branch merges with remote dev-branch
    master     merges with remote master
  Local refs configured for 'git push':
    dev-branch                     pushes to dev-branch                     (up to date)
    markdown-strip                 pushes to markdown-strip                 (up to date)
    master                         pushes to master                         (up to date)
~~~    
Данная команда показывает какая именно локальная ветка будет отправлена на удалённый сервер по умолчанию при выполнении git push. Она также показывает, каких веток с удалённого сервера у вас ещё нет, какие ветки всё ещё есть у вас, но уже удалены на сервере, и для нескольких веток показано, какие удалённые ветки будут в них влиты при выполнении git pull.

*Удаление и переименование удалённых репозиториев*

Для переименования удалённого репозитория можно выполнить git remote rename. Например, если вы хотите переименовать pb в paul, вы можете это сделать при помощи git remote rename:
~~~
$ git remote rename pb paul
$ git remote
origin
paul
~~~
Стоит упомянуть, что это также изменит имена удалённых веток в вашем репозитории. То, к чему вы обращались как pb/master, теперь стало paul/master.

Если по какой-то причине вы хотите удалить удалённый репозиторий — вы сменили сервер или больше не используете определённое зеркало, или кто-то перестал вносить изменения — вы можете использовать git remote rm:
~~~
$ git remote remove paul
$ git remote
origin
~~~
При удалении ссылки на удалённый репозиторий все отслеживаемые ветки и настройки, связанные с этим репозиторием, так же будут удалены.

# Репозиторий для **pull request**
* В своём аккаунте на GitHub создать копию репозитория **"AndreyBulgakov19/SCV_Git_PR"** с помощью кнопки **"Fork"**.
---
* Клонировать копию репозитория на локальный компьютер.
---
* Создать новую ветку.
---
* Добавить файл с инструкцией в новую ветку.
---
* Дополнить инструкцию разделами по работе с удалёнными репозиториями, pull request.
---
* Зафиксировать изменения (коммиты).
---
* Отправить изменения на GitHub.
---
* На сайте GitHub выполнить **Pull request**.
---

